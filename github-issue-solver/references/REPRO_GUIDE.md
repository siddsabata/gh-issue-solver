# Reproduction Harness Guide

## Purpose

A reproduction harness proves the bug exists and confirms when it's fixed. It must be:
- **Deterministic**: Same result every run
- **Self-contained**: Runs from repo root with no manual setup
- **Binary**: Exit 0 = fixed, Exit 1 = bug present

## Directory Structure

```
.claude-github-issue-solver/repro/
├── repro.sh           # Main reproduction script
├── README.md          # Instructions for maintainers
└── fixtures/          # Any test data needed
    └── ...
```

## repro.sh Template

```bash
#!/usr/bin/env bash
set -euo pipefail

# ============================================================
# Reproduction script for GitHub Issue #<NUM>
# Generated by github-issue-solver skill
# ============================================================

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"

cd "$REPO_ROOT"

echo "=== Environment ==="
echo "OS: $(uname -s) $(uname -r)"
echo "Python: $(python3 --version)"
echo "uv: $(uv --version)"
echo "PWD: $(pwd)"
echo "==================="
echo

# Install dependencies if needed
uv sync --quiet

# Run the reproduction
echo "Running reproduction..."

# OPTION A: Python script reproduction
uv run python3 - <<'PYTHON'
# Inline Python code that reproduces the bug
# This should:
# 1. Set up minimal conditions
# 2. Execute the buggy code path
# 3. Assert expected vs actual behavior

import sys

# ... reproduction code ...

# Exit with appropriate code
# sys.exit(0)  # Bug is FIXED
# sys.exit(1)  # Bug is PRESENT
PYTHON

# OPTION B: Direct command reproduction
# uv run python3 some_script.py --args
# Check exit code or output

# OPTION C: Import and test
# uv run python3 -c "from package import thing; assert thing.works()"

EXIT_CODE=$?

echo
if [ $EXIT_CODE -eq 0 ]; then
    echo "=== PASS: Bug appears to be fixed ==="
else
    echo "=== FAIL: Bug is still present ==="
fi

exit $EXIT_CODE
```

## README.md Template

```markdown
# Reproduction for Issue #<NUM>

## Quick Start

From repo root:
\`\`\`bash
bash .claude-github-issue-solver/repro/repro.sh
\`\`\`

## Expected Results

- **FAIL (exit 1)**: Bug is present - [describe what happens]
- **PASS (exit 0)**: Bug is fixed - [describe expected behavior]

## What This Tests

[Brief description of the bug and what the repro validates]

## Dependencies

- Python 3.x
- uv package manager
- [any other requirements]
```

## Writing Good Reproductions

### Minimize

Remove everything not needed to trigger the bug:
- Use smallest possible input
- Remove unrelated imports
- Simplify configuration

### Isolate

Avoid dependencies on:
- External services (mock if needed)
- Specific file paths (use temp dirs)
- Timing-dependent behavior
- Random values (seed if needed)

### Assert Clearly

```python
# Bad: Silent failure
result = buggy_function()

# Good: Clear assertion
result = buggy_function()
expected = "correct_value"
if result != expected:
    print(f"FAIL: Expected {expected!r}, got {result!r}")
    sys.exit(1)
print("PASS: Function returned expected value")
sys.exit(0)
```

### Handle Exceptions

```python
try:
    result = function_that_should_not_raise()
    print("PASS: No exception raised")
    sys.exit(0)
except SpecificError as e:
    print(f"FAIL: Raised {type(e).__name__}: {e}")
    sys.exit(1)
```

Or for exceptions that SHOULD be raised:

```python
try:
    function_that_should_raise()
    print("FAIL: Expected exception was not raised")
    sys.exit(1)
except ExpectedError:
    print("PASS: Correct exception raised")
    sys.exit(0)
```

## Common Patterns

### Testing CLI behavior

```bash
OUTPUT=$(uv run python3 -m package.cli --flag 2>&1)
if echo "$OUTPUT" | grep -q "expected pattern"; then
    echo "PASS"
    exit 0
else
    echo "FAIL: Output did not contain expected pattern"
    echo "Got: $OUTPUT"
    exit 1
fi
```

### Testing with fixtures

```bash
# Create fixture
cat > "$SCRIPT_DIR/fixtures/test_input.json" <<'EOF'
{"key": "value"}
EOF

# Run with fixture
uv run python3 -c "
import json
with open('$SCRIPT_DIR/fixtures/test_input.json') as f:
    data = json.load(f)
# ... test logic ...
"
```

### Testing import behavior

```bash
uv run python3 -c "
from package.module import function
# If we get here without ImportError, test passes
print('PASS: Import successful')
" || { echo "FAIL: Import failed"; exit 1; }
```

## Iteration

If initial repro fails to capture the bug:

1. Re-read the issue for missed details
2. Check environment differences
3. Try exact code from issue reporter
4. Ask user for clarification after 2 failed attempts

Update repro.sh and re-run until it reliably shows:
- FAIL before fix is applied
- PASS after fix is applied
